/*
 * generated by Xtext 2.12.0
 */
package eu.jgen.notes.uaf.proc.test

import com.ca.gen.jmmi.EncyManager
import com.ca.gen.jmmi.Model
import com.ca.gen.jmmi.ModelManager
import com.ca.gen.jmmi.schema.ObjTypeCode
import com.google.inject.Inject
import eu.jgen.notes.annot.desc.annotation.Metadata
import eu.jgen.notes.uaf.proc.AnnotationInjectorProvider
import eu.jgen.notes.uaf.proc.UserAddedFunctionProcessor
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.AfterClass
import org.junit.BeforeClass
import org.junit.Test
import org.junit.runner.RunWith
import java.util.HashMap
import eu.jgen.notes.annot.desc.processor.AnnotationWorker

@RunWith(XtextRunner)
@InjectWith(AnnotationInjectorProvider)
class UafProcessorTest {

	@Inject  AnnotationWorker worker
	

	@BeforeClass
	def static void setUpBeforeClass() throws Exception {

	}

	@AfterClass
	def static void tearDownAfterClass() throws Exception {
	}
 
	@Test
	def void loadModel() {
		var options = new HashMap<String, String>();
         options.put("dir", "C:\\jgen.notes.models\\func.ief");

		var ency = EncyManager.connectLocalForReadOnly("C:\\jgen.notes.models\\func.ief");
		 var model = ModelManager.open(ency, ency.getModelIds().get(0));
		var objIds = model.getObjIds(ObjTypeCode.ACBLKBSD)
		worker.init( model, new UserAddedFunctionProcessor(), options).setSources(objIds).activate
		

	}
}
